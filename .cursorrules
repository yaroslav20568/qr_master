# Flutter Development Rules

## Архитектура и структура проекта

### Структура проекта
- Четкое разделение на слои: screens, services, widgets, models, utils, constants
- Каждый экран в отдельной папке с собственными виджетами и логикой
- Сервисы вынесены в отдельную папку services/
- Модели данных в папке models/
- Утилиты и хелперы в папке utils/
- Константы в папке constants/

### Структура виджетов
- Если виджет относится только к одному конкретному экрану, размещать его в папке `widgets/name_screen/` (например, `widgets/calculator_screen/`)
- Если виджет переиспользуемый (reusable) во многих местах или ui-виджет, размещать его в папке `widgets/ui/`
- Все виджеты должны быть экспортированы через соответствующие index.dart файлы

### Структура экранов
- Каждый экран должен состоять из виджетов, а не содержать большие куски верстки напрямую в build методе
- Большие блоки верстки должны быть вынесены в отдельные виджеты, особенно если они имеют локальное состояние, которое не нужно в других виджетах
- Экран должен быть композицией виджетов, а не монолитным блоком кода
- Если виджет имеет собственное локальное состояние и используется только в одном экране, он должен быть размещен в `widgets/name_screen/`

### Public API и импорты
- Каждый слой должен иметь index.dart файл (публичный API слоя)
- Слои импортируют данные других слоев ТОЛЬКО через index.dart (рутовый файл слоя)
- Внутри каждого слоя можно импортировать файлы напрямую
- Все экспорты из слоя должны быть в index.dart
- Запрещено использовать относительные импорты (../ или ./) - всегда использовать полные package: импорты
- Пример правильного импорта: `import 'package:ai_meal_planner/models/index.dart'`
- Пример неправильного импорта: `import '../models/index.dart'` или `import './widgets/button.dart'`
- Всегда использовать полный путь через package:ai_meal_planner/

### Организация кода
- Понятные и описательные названия файлов, функций и переменных
- Один класс/виджет на файл
- Избегать дублирования логики - выносить в общие сервисы/утилиты
- Минимизировать зависимости - добавлять только необходимые пакеты
- Использовать принципы SOLID и KISS
- Очищать неиспользуемый код
- Код должен быть читаемым и самодокументируемым

### Структура приложения
- Навигация между разделами должна быть четкой и понятной
- Использовать Navigator или Router для навигации

## Логирование и обработка ошибок

### Обработка ошибок
- Все API-запросы должны иметь обработку ошибок (try-catch)
- Использовать Result/Either паттерн для обработки ошибок
- Показывать пользователю понятные сообщения об ошибках
- Не показывать технические детали ошибок пользователю
- Обрабатывать различные типы ошибок: сетевые, таймауты, серверные ошибки, ошибки парсинга

### Логирование
- Логировать важные действия, особенно API/AI-интеграции
- Использовать уровни логирования (debug, info, warning, error)
- Запрещено логировать чувствительные данные (токены, пароли, персональные данные)
- Использовать пакет logger или аналогичный для структурированного логирования
- Логировать начало и завершение API-запросов
- Логировать ошибки AI-интеграций с контекстом запроса (без чувствительных данных)

### Пример обработки ошибок:
```dart
try {
  logger.info('Starting API request: fetchData');
  final result = await apiService.fetchData();
  logger.info('API request completed successfully');
} on NetworkException catch (e) {
  logger.error('Network error during fetchData', error: e);
} on TimeoutException catch (e) {
  logger.error('Request timeout', error: e);
} on ServerException catch (e) {
  logger.error('Server error', error: e);
} catch (e) {
  logger.error('Unexpected error', error: e);
}
```

## Производительность и стабильность

### Требования к стабильности
- Приложение должно запускаться без ошибок
- Отсутствие заметных зависаний, особенно при запросах
- Корректная обработка состояний загрузки (loading, error, success)
- Graceful degradation при отсутствии интернета

### Оптимизация рендеринга
- Минимизировать перерисовки - использовать const конструкторы где возможно
- Использовать const для статических виджетов
- Применять RepaintBoundary для изоляции перерисовок
- Использовать ListView.builder для длинных списков вместо ListView
- Избегать создания виджетов в build методах без необходимости

### Управление состоянием
- Если это локальный state в виджете используй setState, если нужен глобальный state между скринами 
используй глобальный state management (Provider)
- Избегать лишних setState() вызовов
- Оптимизировать rebuilds - обновлять только необходимые виджеты
- Не использовать setState() в build методах

### Адаптивность
- Поддержка разных размеров экранов (responsive design)
- Использовать MediaQuery для адаптации под размеры экрана
- Тестировать на разных размерах экранов (маленькие, средние, большие)
- Использовать LayoutBuilder для адаптивных виджетов
- Обеспечить корректное отображение на всех устройствах

### Производительность
- Оптимизировать изображения (сжатие, правильные форматы)
- Ленивая загрузка ресурсов где возможно
- Избегать синхронных операций в UI потоке
- Использовать async/await для асинхронных операций
- Оптимизировать размер APK

### Структура приложения
- Базовый, но аккуратный дизайн
- Иконка приложения должна быть создана и добавлена
- Проект должен собираться под Android без ошибок

### Требования к качеству
- Приложение запускается без ошибок
- UI минимальный, но аккуратный
- Весь функционал работает корректно
- Нет критических багов
- Все ресурсы оптимизированы

## Flutter специфичные правила

### Виджеты
- Использовать StatelessWidget где возможно
- StatefulWidget только когда необходимо управление состоянием
- Разбивать большие виджеты на маленькие переиспользуемые компоненты
(200-300 строк кода максимальный всё что больше лучше декомпозировать)
- Использовать виджеты из Material/Cupertino библиотек
- Виджеты, специфичные для одного экрана, размещать в `widgets/name_screen/`
- Переиспользуемые UI-виджеты размещать в `widgets/ui/`

### Асинхронность
- Всегда использовать async/await вместо .then()
- Обрабатывать Future правильно
- Использовать FutureBuilder/StreamBuilder для асинхронных данных
- Не блокировать UI поток

### Ресурсы
- Изображения в папке assets/images/
- Иконки в папке assets/icons/
- Шрифты в папке assets/fonts/
- Все ресурсы должны быть объявлены в pubspec.yaml
- Оптимизировать размеры ресурсов

### Константы цветов
- Все цвета приложения должны быть определены в файле constants/app_colors.dart
- Использовать именованные константы для цветов вместо хардкода значений
- Цвета должны быть экспортированы через constants/index.dart
- Пример структуры: `static const Color primaryColor = Color(0xFF...);`
- Использовать Material Design цветовую палитру где возможно
- Определять цвета для светлой и темной темы если необходимо

## Язык приложения

### Язык интерфейса и сообщений
- Все строки в приложении должны быть на английском языке
- Сообщения об ошибках, подсказки, текст UI - все на английском
- Промпты для AI могут быть на английском или русском в зависимости от задачи, но предпочтительно английский
- Исключения и сообщения об ошибках в коде должны быть на английском

## Код стиль

### Именование
- Файлы: snake_case (example_screen.dart)
- Классы: PascalCase (ExampleScreen)
- Переменные и функции: camelCase (exampleVariable)
- Константы: lowerCamelCase с префиксом k (kExampleConstant) или UPPER_SNAKE_CASE

### Форматирование
- Следовать правилам dart format
- Максимальная длина строки: 80-100 символов
- Использовать trailing commas для лучшего форматирования
- Правильные отступы (2 пробела)

### Комментарии
- Не добавлять комментарии любых видов (// или /* */)
- Код должен быть самодокументируемым через понятные названия

## Тестирование и сборка

### Сборка проекта
- Проект должен собираться без ошибок и предупреждений
- Использовать flutter analyze для проверки кода
- Использовать flutter format для форматирования

## Запрещенные практики

- Не использовать print() для логирования - использовать logger
- Не хардкодить строки - использовать локализацию или константы
- Не создавать виджеты в build методах без необходимости
- Не использовать setState() в build методах
- Не игнорировать ошибки (не использовать catch без обработки)
- Не добавлять неиспользуемые зависимости
- Не оставлять неиспользуемый код
- Не логировать чувствительные данные
- Не показывать технические детали ошибок пользователю
